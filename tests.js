$(document).ready(function () {

  QUnit.test( "Test getAbstractForDocTitle()", function( assert ) {
    assert.expect(1);
    var correctAbstract = "Web applications can be easily made available to an international audience by leveraging frameworks and tools for automatic translation and localization. However, these automated changes can distort the appearance of web applications since it is challenging for developers to design their websites to accommodate the expansion and contraction of text after it is translated to another language. Existing web testing techniques do not support developers in checking for these types of problems and manually checking every page in every language can be a labor intensive and error prone task. To address this problem, we introduce an automated technique for detecting when a web page's appearance has been distorted due to internationalization efforts and identifying the HTML elements or text responsible for the observed problem. In evaluation, our approach was able to detect internationalization problems in a set of 54 web applications with high precision and recall and was able to accurately identify the underlying elements in the web pages that led to the observed problem."
    var abstract;

    function getAbstractForDocTitle(title){
      $.ajax({
        url: "http://ieeexplore.ieee.org/gateway/ipsSearch.jsp?ti="+title,
        dataType: "xml",
        success: function( response ) {
          abstract = response.getElementsByTagName("document")[0].getElementsByTagName("abstract")[0]["textContent"];
          console.log(abstract);
        }
      });
    }

    var input = "Detecting and Localizing Internationalization Presentation Failures in Web Applications"
    getAbstractForDocTitle(input);

    var done = assert.async();
    setTimeout(function(){
      assert.deepEqual(abstract, correctAbstract);
      console.log("after timeout: " + abstract);
      done();
    }, 4000);

  });


  QUnit.test( "Test Getting papers for keywords", function( assert ) {
    assert.expect(1);
    var correctAbstract = "Medical imaging currently relies on several techniques, including X-rays, magnetic resonance, and echography. However, these techniques exhibit drawbacks, and alternative approaches are required. Microwave imaging has been proposed as a possible solution, especially for breast cancer imaging. However, most of these systems work with a central frequency of a few gigahertz, and this leads to a suboptimum resolution, which can jeopardize the image quality. Millimeter waves can provide superior resolutions, at the cost of a lower penetration depth within the breast tissue. In addition, a significant fraction of the power generated by a mm-wave imaging system would be reflected back from the skin. For these reasons, and also considering that mm-wave transmitters and receivers have been historically outperformed by microwave counterparts in terms of available power and sensitivity, mm-wave imaging has not been considered a possible solution. This paper contributes to demonstrate a paradigm shift toward the possible use of mm-waves for breast cancer imaging of targets a few centimeter below the skin, a useful penetration depth for several cases. All key points are addressed using analytical, full-wave, and multiphysics simulations, including the system architecture (linear and conformal), the safety aspects (power density, specific absorption rate, and temperature increase), and the use of realistic breast models derived from ex vivo measurements."
    var abstract;

    function getPapersForWords(search){
      $.ajax({
        url: "http://ieeexplore.ieee.org/gateway/ipsSearch.jsp?querytext="+search,
        dataType: "xml",
        success: function( response ) {
          abstract = response.getElementsByTagName("document")[0].getElementsByTagName("abstract")[0]["textContent"];
        }
      });
    }

    var input = "parallel algorithms";
    getPapersForWords(input);

    var done = assert.async();
    setTimeout(function(){
      assert.deepEqual(abstract, correctAbstract);
      done();
    }, 4000);
  });

  QUnit.test( "Test Save Previous Searches", function( assert ) {
    assert.expect(1);
    var correctAuthor = "Test Author";
    var author = "";

    var request = $.ajax({
            url: "StoreAuthor.php",
            type: "POST",
            data: {author : correctAuthor},
            dataType: "text"
          });
          request.done(function(msg){
            getPreviousSearches;
          });

    function getPreviousSearches() {
      var request = $.ajax({
        url: "GetPrevSearches.php",
        type: "GET",
        dataType: "JSON"
      });

      request.done(function(msg) {
        var array = msg;
        console.log("Before delete: " + msg);

        if (array.length != 0){
          for (var i = 0; i < array.length; i++){
            if(correctAuthor == array[i]){
              author = array[i];
            }
          }
        }

        $.ajax({
          url: "RemoveTestAuthor.php",
          type: "GET",
          dataType: "JSON",
          success: function(response){
            console.log(response);
          }
        });        
      });
    }

    getPreviousSearches();

    var done = assert.async();
    setTimeout(function(){
      assert.deepEqual(author, correctAuthor);
      done();
    }, 4000);
    
  });

  QUnit.test( "Test Store Current Word", function( assert ) {
    assert.expect(1);
    var correctWord = "algorithm";
    var testWord;
    var originalWord;

    function storeCurrentWord(word){
      
      $.ajax({
        url: "GetCurrentWord.php",
        type: "GET",
        dataType: "text",
        success: function(response){
          console.log("original word:" +response);
          originalWord = response;

          var request = $.ajax({
            url: "StoreCurrentWord.php",
            type: "POST",
            data: {word : word},
            dataType: "text"
          });
          request.done(function(msg) {
            console.log("after storing test word: " + msg);
            testWord = msg;
            $.ajax({
              url: "StoreCurrentWord.php",
              type: "POST",
              data: {word: originalWord},
              dataType: "text",
              success: function(response){
                console.log("reseting to original word:" + response);
              }
            });
          });
        }
      });
    }

    var input = correctWord;
    storeCurrentWord(input);

    var done = assert.async();
    setTimeout(function(){
      assert.deepEqual(testWord, correctWord);
      console.log("after timeout, word: " + testWord);
      console.log("after timeout, originalWord: " + originalWord);
      done();
    }, 4000);

  });
})
